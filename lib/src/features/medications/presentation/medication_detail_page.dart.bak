import 'package:dosifi_v5/src/features/medications/presentation/medication_display_helpers.dart';
// Dart imports:

import 'dart:ui';

// Flutter imports:
import 'package:flutter/material.dart';

// Package imports:
import 'package:go_router/go_router.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:intl/intl.dart';

// Project imports:
import 'package:dosifi_v5/src/core/design_system.dart';
import 'package:dosifi_v5/src/features/medications/domain/enums.dart';
import 'package:dosifi_v5/src/features/medications/domain/medication.dart';
import 'package:dosifi_v5/src/features/medications/presentation/reconstitution_calculator_dialog.dart';
import 'package:dosifi_v5/src/features/schedules/domain/dose_log.dart';
import 'package:dosifi_v5/src/features/schedules/domain/schedule.dart';
import 'package:dosifi_v5/src/features/schedules/presentation/widgets/schedule_card.dart';
import 'package:dosifi_v5/src/widgets/app_header.dart';
import 'package:dosifi_v5/src/widgets/detail_page_scaffold.dart';
import 'package:dosifi_v5/src/widgets/reconstitution_summary_card.dart';
import 'package:dosifi_v5/src/widgets/stock_donut_gauge.dart';

/// Modern, revolutionized medication detail screen with:
/// - Hero header with gradient and key stats
/// - Interactive quick action cards
/// - Visual stock progress indicators
/// - Clean sectioned information display
/// - Responsive layout for all screen sizes
const double _kDetailHeaderExpandedHeight = 325;
const double _kDetailHeaderCompactHeight = 245;
const double _kDetailHeaderCollapsedHeight = 56;

class MedicationDetailPage extends StatefulWidget {
  const MedicationDetailPage({super.key, this.medicationId, this.initial});
  final String? medicationId;
  final Medication? initial;

  @override
  State<MedicationDetailPage> createState() => _MedicationDetailPageState();
}

class _AdherenceBarPainter extends CustomPainter {
  final List<double> data;
  final Color color;

  _AdherenceBarPainter({required this.data, required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..style = PaintingStyle.fill;

    final barWidth = size.width / (data.length * 2 - 1);
    final spacing = barWidth;

    for (int i = 0; i < data.length; i++) {
      final value = data[i];
      final x = i * (barWidth + spacing);

      if (value < 0) {
        paint.color = color.withValues(alpha: 0.2);
        canvas.drawRRect(
          RRect.fromRectAndRadius(
            Rect.fromLTWH(x, size.height - 2, barWidth, 2),
            const Radius.circular(1),
          ),
                    ],
                    _HeaderInfoTile(
                      icon: med.activeVialRequiresFreezer
      }
    }
  }

                      label: med.activeVialRequiresFreezer
  bool shouldRepaint(covariant _AdherenceBarPainter oldDelegate) {
    return oldDelegate.data != data || oldDelegate.color != color;
  }
}
                      value: storageLabel,
                      textColor: onPrimary,
                      trailingIcon: med.activeVialLightSensitive
                          ? Icons.dark_mode_outlined
                          : null,
                    ),

class _HeaderInfoTile extends StatelessWidget {
  final String label;
  final String value;
  final IconData? icon;
  final Color? textColor;
  final IconData? trailingIcon;

  const _HeaderInfoTile({
    required this.label,
    required this.value,
    this.icon,
    this.textColor,
    this.trailingIcon,
  });

  @override
  Widget build(BuildContext context) {
    final color = textColor ?? Colors.white;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: TextStyle(color: color.withValues(alpha: 0.7), fontSize: 10),
        ),
        const SizedBox(height: 4),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null) ...[
              Icon(icon, color: color, size: 14),
              const SizedBox(width: 4),
            ],
            Text(
              value,
              style: TextStyle(
                color: color,
                fontWeight: FontWeight.bold,
                fontSize: 12,
              ),
            ),
            if (trailingIcon != null) ...[
              const SizedBox(width: 4),
              Icon(trailingIcon, color: color, size: 14),
            ],
          ],
        ),
      ],
    );
  }
}

class _BooleanChip extends StatelessWidget {
  const _BooleanChip({
    required this.label,
    required this.value,
    required this.onChanged,
  });

  final String label;
  final bool value;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return FilterChip(
      label: Text(label),
      selected: value,
      onSelected: onChanged,
      showCheckmark: true,
      checkmarkColor: value ? colorScheme.onPrimaryContainer : null,
      selectedColor: colorScheme.primaryContainer,
      labelStyle: TextStyle(
        color: value ? colorScheme.onPrimaryContainer : colorScheme.onSurface,
        fontWeight: value ? FontWeight.bold : FontWeight.normal,
        fontSize: 12,
      ),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: value
              ? Colors.transparent
              : colorScheme.outline.withValues(alpha: 0.3),
        ),
      ),
    );
  }
}

class _MedicationDetailPageState extends State<MedicationDetailPage> {
  late ScrollController _scrollController;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final box = Hive.box<Medication>('medications');
    final med =
        widget.initial ??
        (widget.medicationId != null ? box.get(widget.medicationId) : null);

    if (med == null) {
      return Scaffold(
        appBar: const GradientAppBar(
          title: 'Medication',
          forceBackButton: true,
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.medication_outlined,
                size: 64,
                color: Theme.of(context).colorScheme.outline,
              ),
              const SizedBox(height: 16),
              Text(
                'Medication not found',
                style: Theme.of(context).textTheme.titleMedium,
              ),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      body: AnimatedBuilder(
        animation: Listenable.merge([
          box.listenable(),
          Hive.box<Schedule>('schedules').listenable(),
          Hive.box<DoseLog>('dose_logs').listenable(),
          _scrollController,
        ]),
        builder: (context, _) {
          final updatedMed = box.get(med.id) ?? med;
          final theme = Theme.of(context);
          final colorScheme = theme.colorScheme;
          final onPrimary = colorScheme.onPrimary;

          // Check if we have schedules to determine header height
          final scheduleBox = Hive.box<Schedule>('schedules');
          final hasSchedules = scheduleBox.values.any(
            (s) => s.medicationId == updatedMed.id && s.active,
          );
          final headerHeight = hasSchedules
              ? _kDetailHeaderExpandedHeight
              : _kDetailHeaderCompactHeight;

          // Calculate scroll progress for title opacity
          final offset = _scrollController.hasClients
              ? _scrollController.offset
              : 0.0;
          final maxOffset = headerHeight - _kDetailHeaderCollapsedHeight;
          final scrollProgress = (offset / maxOffset).clamp(0.0, 1.0);

          return CustomScrollView(
            controller: _scrollController,
            slivers: [
              // Combined AppBar and Stats Banner in one SliverAppBar
              SliverAppBar(
                toolbarHeight: _kDetailHeaderCollapsedHeight,
                expandedHeight: headerHeight,
                collapsedHeight: _kDetailHeaderCollapsedHeight,
                floating: false,
                pinned: true,
                backgroundColor: Colors.transparent,
                foregroundColor: onPrimary,
                iconTheme: IconThemeData(color: onPrimary),
                actionsIconTheme: IconThemeData(color: onPrimary),
                elevation: 0,
                flexibleSpace: LayoutBuilder(
                  builder: (context, constraints) {
                    final top = MediaQuery.of(context).padding.top;
                    final collapsedHeight = _kDetailHeaderCollapsedHeight + top;
                    final expandedHeight = headerHeight;
                    final currentHeight = constraints.maxHeight;
                    final scrollOffset = expandedHeight - currentHeight;

                    // t goes from 0.0 (expanded) to 1.0 (collapsed)
                    final t =
                        (1.0 -
                                (currentHeight - collapsedHeight) /
                                    (expandedHeight - collapsedHeight))
                            .clamp(0.0, 1.0);

                    return Stack(
                      children: [
                        // Gradient Background
                        Container(
                          decoration: const BoxDecoration(
                            gradient: LinearGradient(
                              begin: Alignment.topLeft,
                              end: Alignment.bottomRight,
                              colors: [Color(0xFF09A8BD), Color(0xFF18537D)],
                            ),
                          ),
                        ),
                        // Content (minus Name)
                        Positioned(
                          top: -scrollOffset,
                          left: 0,
                          right: 0,
                          child: Opacity(
                            opacity: (1.0 - t * 2.0).clamp(0.0, 1.0),
                            child: SafeArea(
                              child: Padding(
                                padding: const EdgeInsets.fromLTRB(
                                  kPageHorizontalPadding,
                                  4, // Reduced from 12
                                  kPageHorizontalPadding,
                                  kSpacingS,
                                ),
                                child: _buildStatsBannerContent(
                                  context,
                                  updatedMed,
                                  hideName: true,
                                ),
                              ),
                            ),
                          ),
                        ),
                        // Animated Name
                        Positioned(
                          top: lerpDouble(
                            top + 48,
                            top + (_kDetailHeaderCollapsedHeight - 26) / 2,
                            t,
                          ),
                          left: lerpDouble(kPageHorizontalPadding, 0, t),
                          right: lerpDouble(
                            120,
                            0,
                            t,
                          ), // Constrain width when expanded
                          child: Align(
                            alignment: Alignment.lerp(
                              Alignment.centerLeft,
                              Alignment.center,
                              t,
                            )!,
                            child: GestureDetector(
                              onTap: () => _editName(context, updatedMed),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Flexible(
                                    child: Text(
                                      updatedMed.name,
                                      style: TextStyle(
                                        color: onPrimary,
                                        fontSize: lerpDouble(22, 17, t),
                                        fontWeight: FontWeight.w600,
                                      ),
                                      maxLines: 1,
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                  const SizedBox(width: 8),
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 6,
                                      vertical: 1,
                                    ),
                                    decoration: BoxDecoration(
                                      color: onPrimary.withValues(alpha: 0.2),
                                      borderRadius: BorderRadius.circular(4),
                                      border: Border.all(
                                        color: onPrimary.withValues(alpha: 0.3),
                                        width: 0.5,
                                      ),
                                    ),
                                    child: Text(
                                      _formLabel(updatedMed.form),
                                      style: TextStyle(
                                        color: onPrimary,
                                        fontSize: 10,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      ],
                    );
                  },
                ),
                leading: IconButton(
                  icon: const Icon(Icons.arrow_back),
                  onPressed: () => context.pop(),
                ),
                title: Opacity(
                  opacity: (1.0 - scrollProgress * 3).clamp(0.0, 1.0),
                  child: Text(
                    'Medication Details',
                    style: TextStyle(
                      color: onPrimary,
                      fontSize: 17,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                centerTitle: true,
                actions: [
                  // Menu button
                  PopupMenuButton<String>(
                    icon: const Icon(Icons.menu),
                    onSelected: (value) {
                      switch (value) {
                        case 'home':
                          context.go('/');
                        case 'medications':
                          context.go('/medications');
                        case 'supplies':
                          context.go('/supplies');
                        case 'schedules':
                          context.go('/schedules');
                        case 'calendar':
                          context.go('/calendar');
                        case 'reconstitution':
                          context.push('/medications/reconstitution');
                        case 'analytics':
                          context.go('/analytics');
                        case 'settings':
                          context.go('/settings');
                      }
                    },
                    itemBuilder: (context) => const [
                      PopupMenuItem(value: 'home', child: Text('Home')),
                      PopupMenuItem(
                        value: 'medications',
                        child: Text('Medications'),
                      ),
                      PopupMenuItem(value: 'supplies', child: Text('Supplies')),
                      PopupMenuItem(
                        value: 'schedules',
                        child: Text('Schedules'),
                      ),
                      PopupMenuItem(value: 'calendar', child: Text('Calendar')),
                      PopupMenuItem(
                        value: 'reconstitution',
                        child: Text('Reconstitution Calculator'),
                      ),
                      PopupMenuItem(
                        value: 'analytics',
                        child: Text('Analytics'),
                      ),
                      PopupMenuItem(value: 'settings', child: Text('Settings')),
                    ],
                  ),
                ],
              ),
              // Reconstitution Card (if applicable)
              if (updatedMed.form == MedicationForm.multiDoseVial)
                SliverToBoxAdapter(
                  child: _buildReconstitutionCard(context, updatedMed),
                ),

              // Main details
              SliverToBoxAdapter(
                child: _buildUnifiedDetailsCard(
                  context,
                  updatedMed,
                  _nextDoseForMedication(updatedMed.id),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  String _formatDateTime(DateTime dt) {
    return DateFormat('MMM d, h:mm a').format(dt);
  }

  // Removed unused `_buildInfoRow` helper to reduce duplication in other files.

  Widget _buildUnifiedDetailsCard(
    BuildContext context,
    Medication med,
    ScheduledDose? nextDose,
  ) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Card(
      margin: EdgeInsets.zero,
      color: Theme.of(context).colorScheme.surface,
      elevation: 1,
      clipBehavior: Clip.antiAlias,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(kBorderRadiusMedium),
        side: BorderSide(
          color: Theme.of(
            context,
          ).colorScheme.outlineVariant.withValues(alpha: kCardBorderOpacity),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 1. Schedule / Next Dose
            _buildSectionTitle(context, 'Schedule & Next Dose'),
            const SizedBox(height: 16),
            _buildScheduleSection(context, med, nextDose),
            const Divider(height: 32),

            // 2. Medication Info
            Row(
              children: [
                Expanded(child: _buildSectionTitle(context, 'Medication Info')),
                IconButton(
                  icon: Icon(
                    Icons.edit_outlined,
                    color: Theme.of(context).colorScheme.primary,
                  ),
                  onPressed: () => _showMedicationInfoEditorSheet(context, med),
                  tooltip: 'Edit Medication Info',
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildMedicationInfoSection(context, med),
            const Divider(height: 32),

            // 3. Active Vial (MDV Only)
            if (med.form == MedicationForm.multiDoseVial) ...[
              _buildSectionTitle(context, 'Active Vial (In Use)'),
              const SizedBox(height: 16),
              _buildActiveVialSection(context, med),
              const Divider(height: 32),
            ],

            // 4. Backup Stock (MDV Only)
            if (med.form == MedicationForm.multiDoseVial) ...[
              _buildSectionTitle(context, 'Backup Stock (Sealed)'),
              const SizedBox(height: 16),
              _buildBackupStockSection(context, med),
              const Divider(height: 32),
            ],

            // 5. General Information
            _buildSectionTitle(context, 'General Information'),
            const SizedBox(height: 16),
            _buildGeneralInfoSection(context, med),

            const SizedBox(height: 24),
            Center(
              child: TextButton.icon(
                onPressed: () => _deleteMedication(context, med),
                icon: Icon(Icons.delete_outline, color: colorScheme.error),
                label: Text(
                  'Delete Medication',
                  style: TextStyle(color: colorScheme.error),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Text(title, style: sectionTitleStyle(context));
  }

  Widget _buildScheduleSection(
    BuildContext context,
    Medication med,
    ScheduledDose? nextDose,
  ) {
    final logsBox = Hive.box<DoseLog>('dose_logs');
    final logs = logsBox.values
        .where((log) => log.medicationId == med.id)
        .toList();
    final lastDose = logs.isNotEmpty
        ? logs.reduce((a, b) => a.actionTime.isAfter(b.actionTime) ? a : b)
        : null;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (nextDose != null && nextDose.schedule != null)
          ScheduleCard(s: nextDose.schedule!, dense: false, useGradient: false)
        else ...[
          Text(
            'No upcoming doses scheduled',
            style: bodyTextStyle(
              context,
            )?.copyWith(color: Theme.of(context).colorScheme.onSurface),
          ),
          const SizedBox(height: 12),
          FilledButton.icon(
            onPressed: () => context.go('/schedules'),
            icon: const Icon(Icons.add_alarm),
            label: const Text('Add Schedule'),
          ),
        ],
        if (lastDose != null) ...[
          const SizedBox(height: 16),
          Text(
            'Last taken: ${_formatDateTime(lastDose.actionTime)}',
            style: helperTextStyle(context)?.copyWith(
              fontSize: 12,
              color: Theme.of(context).colorScheme.onSurface,
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildMedicationInfoSection(BuildContext context, Medication med) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildCompactInfoItem(
          context,
          label: 'Name',
          value: med.name,
          onTap: () => _editName(context, med),
        ),
        const SizedBox(height: 8),
        if (med.manufacturer != null && med.manufacturer!.isNotEmpty) ...[
          _buildCompactInfoItem(
            context,
            label: 'Manufacturer',
            value: med.manufacturer!,
            onTap: () => _editManufacturer(context, med),
          ),
          const SizedBox(height: 8),
        ],
        _buildCompactInfoItem(
          context,
          label: 'Strength',
          value:
              '${_formatNumber(med.strengthValue)} ${_unitLabel(med.strengthUnit)}',
          onTap: () => _editStrength(context, med),
        ),
        const SizedBox(height: 8),
        _buildCompactInfoItem(
          context,
          label: 'Type',
          value: med.form.name.toUpperCase(),
        ),
        if (med.notes != null && med.notes!.isNotEmpty) ...[
          const SizedBox(height: 8),
          _buildCompactInfoItem(
            context,
            label: 'Notes',
            value: med.notes!,
            onTap: () => _editNotes(context, med),
          ),
        ],
        if (med.description != null && med.description!.isNotEmpty) ...[
          const SizedBox(height: 8),
          _buildCompactInfoItem(
            context,
            label: 'Description',
            value: med.description!,
            onTap: () => _editDescription(context, med),
          ),
        ],
        const SizedBox(height: 8),
        // Storage chips
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _BooleanChip(
              label: 'Refrigerated',
              value: med.requiresRefrigeration,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(med.id, med.copyWith(requiresRefrigeration: v));
              },
            ),
            ActionChip(
              label: Text(med.storageLocation ?? 'Edit storage'),
              onPressed: () => _editStorageLocation(context, med),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildActiveVialSection(BuildContext context, Medication med) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(12),
          margin: const EdgeInsets.only(bottom: 12),
          decoration: BoxDecoration(
            color: Theme.of(
              context,
            ).colorScheme.primaryContainer.withValues(alpha: 0.3),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              Icon(
                Icons.info_outline,
                size: 16,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'Medicine being drawn from for each injection',
                  style: TextStyle(
                    fontSize: 12,
                    color: Theme.of(context).colorScheme.onSurface,
                  ),
                ),
              ),
            ],
          ),
        ),
        if (med.containerVolumeMl != null && med.containerVolumeMl! > 0)
          buildDetailInfoRow(
            context,
            label: 'Volume Remaining',
            value:
                '${_formatNumber(med.activeVialVolume ?? med.containerVolumeMl!)} / ${_formatNumber(med.containerVolumeMl!)} mL',
            highlighted: true,
            onTap: null,
          ),
        _buildCompactGrid(context, [
          _buildCompactInfoItem(
            context,
            label: 'Batch Number',
            value: med.activeVialBatchNumber ?? 'Tap to add',
            onTap: () => _editActiveVialBatch(context, med),
          ),
          _buildCompactInfoItem(
            context,
            label: 'Location',
            value: med.activeVialStorageLocation ?? 'Tap to add',
            onTap: () => _editActiveVialLocation(context, med),
          ),
          _buildCompactInfoItem(
            context,
            label: 'Low Stock Alert',
            value: med.activeVialLowStockMl != null
                ? '${_formatNumber(med.activeVialLowStockMl!)} mL'
                : 'Tap to set',
            onTap: () => _editActiveVialLowStock(context, med),
          ),
        ]),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _BooleanChip(
              label: 'Refrigerated',
              value: med.activeVialRequiresRefrigeration,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(
                  med.id,
                  med.copyWith(activeVialRequiresRefrigeration: v),
                );
              },
            ),
            _BooleanChip(
              label: 'Frozen',
              value: med.activeVialRequiresFreezer,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(med.id, med.copyWith(activeVialRequiresFreezer: v));
              },
            ),
            _BooleanChip(
              label: 'Light Sensitive',
              value: med.activeVialLightSensitive,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(med.id, med.copyWith(activeVialLightSensitive: v));
              },
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildBackupStockSection(BuildContext context, Medication med) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildCompactGrid(context, [
          _buildCompactInfoItem(
            context,
            label: 'Quantity',
            value: '${_formatNumber(med.stockValue)} vials',
            highlighted: true,
            onTap: null,
          ),
          _buildCompactInfoItem(
            context,
            label: 'Batch Number',
            value: med.backupVialsBatchNumber ?? 'Tap to add',
            onTap: () => _editBackupVialBatch(context, med),
          ),
          _buildCompactInfoItem(
            context,
            label: 'Expiry Date',
            value: med.backupVialsExpiry != null
                ? DateFormat('MMMM d, y').format(med.backupVialsExpiry!)
                : 'Tap to set',
            warning:
                med.backupVialsExpiry != null &&
                _isExpiringSoon(med.backupVialsExpiry!),
            onTap: () => _editBackupVialExpiry(context, med),
          ),
          _buildCompactInfoItem(
            context,
            label: 'Location',
            value: med.backupVialsStorageLocation ?? 'Tap to add',
            onTap: () => _editBackupVialLocation(context, med),
          ),
        ]),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _BooleanChip(
              label: 'Refrigerated',
              value: med.backupVialsRequiresRefrigeration,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(
                  med.id,
                  med.copyWith(backupVialsRequiresRefrigeration: v),
                );
              },
            ),
            _BooleanChip(
              label: 'Frozen',
              value: med.backupVialsRequiresFreezer,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(med.id, med.copyWith(backupVialsRequiresFreezer: v));
              },
            ),
            _BooleanChip(
              label: 'Light Sensitive',
              value: med.backupVialsLightSensitive,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(med.id, med.copyWith(backupVialsLightSensitive: v));
              },
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildGeneralInfoSection(BuildContext context, Medication med) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildCompactGrid(context, [
          _buildCompactInfoItem(
            context,
            label: 'Batch Number',
            value: med.batchNumber ?? 'Tap to add',
            onTap: () => _editBatchNumber(context, med),
          ),
          _buildCompactInfoItem(
            context,
            label: 'Expiry Date',
            value: med.expiry != null
                ? DateFormat('MMMM d, y').format(med.expiry!)
                : 'Tap to set',
            warning: med.expiry != null && _isExpiringSoon(med.expiry!),
            onTap: () => _editExpiry(context, med),
          ),
          _buildCompactInfoItem(
            context,
            label: 'Storage Location',
            value: med.storageLocation ?? 'Tap to add',
            onTap: () => _editStorageLocation(context, med),
          ),
          _buildCompactInfoItem(
            context,
            label: 'Low Stock Alert',
            value: med.lowStockEnabled
                ? '${_formatNumber(med.lowStockThreshold ?? 0)} ${_stockUnitLabel(med.stockUnit)}'
                : 'Disabled',
            onTap: () => _editLowStockThreshold(context, med),
          ),
        ]),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _BooleanChip(
              label: 'Refrigerated',
              value: med.requiresRefrigeration,
              onChanged: (bool v) {
                final box = Hive.box<Medication>('medications');
                box.put(med.id, med.copyWith(requiresRefrigeration: v));
              },
            ),
          ],
        ),
        if (med.storageInstructions != null &&
            med.storageInstructions!.isNotEmpty) ...[
          const SizedBox(height: 8),
          _buildCompactInfoItem(
            context,
            label: 'Instructions',
            value: med.storageInstructions!,
            onTap: () => _editStorageInstructions(context, med),
          ),
        ],
      ],
    );
  }

  Widget _buildStatsBannerContent(
    BuildContext context,
    Medication med, {
    bool hideName = false,
  }) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final onPrimary = colorScheme.onPrimary;

    final stockInfo = MedicationDisplayHelpers.calculateStock(med);
    final pct = stockInfo.percentage; // 0..100
    final backupPct = stockInfo.backupPercentage;
    final isMdv = stockInfo.isMdv;
    final manufacturer = med.manufacturer ?? '';

    final primaryLabel = stockInfo.label;
    final donutLabel = stockInfo.isCountUnit
      ? stockInfo.current.toInt().toString()
      : _formatNumber(stockInfo.current);
    final helperLabel = 'Remaining';

    final initial = isMdv
        ? (med.containerVolumeMl ?? stockInfo.total)
        : stockInfo.total;
    final unit = isMdv
        ? 'mL'
        : MedicationDisplayHelpers.stockUnitLabel(med.stockUnit);
    final storageLabel = isMdv
        ? (med.activeVialStorageLocation ?? med.storageLocation ?? '')
        : (med.storageLocation ?? '');

    String strengthPerLabel = 'Strength';
    switch (med.form) {
      case MedicationForm.tablet:
        strengthPerLabel = 'Strength per Tablet';
        break;
      case MedicationForm.capsule:
        strengthPerLabel = 'Strength per Capsule';
        break;
      case MedicationForm.prefilledSyringe:
        strengthPerLabel = 'Strength per Syringe';
        break;
      case MedicationForm.singleDoseVial:
      case MedicationForm.multiDoseVial:
        strengthPerLabel = 'Strength per Vial';
        break;
    }

    Color gaugeColor = onPrimary;
    if (pct <= 10) {
      gaugeColor = theme.colorScheme.errorContainer;
    } else if (pct <= 25) {
      gaugeColor = theme.colorScheme.tertiaryContainer;
    } else {
      gaugeColor = onPrimary.withValues(alpha: 0.9);
    }

    return IntrinsicHeight(
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Space for the animated Name (which is positioned absolutely)
                SizedBox(height: hideName ? 36 : kSpacingM),
                // Manufacturer (Moved below Name)
                if (manufacturer.isNotEmpty) ...[
                  GestureDetector(
                    onTap: () => _editManufacturer(context, med),
                    child: Text(
                      manufacturer,
                      style: helperTextStyle(context)?.copyWith(
                        color: onPrimary.withValues(alpha: kOpacityMediumHigh),
                        decoration: TextDecoration.underline,
                        decorationStyle: TextDecorationStyle.dotted,
                        decorationColor: onPrimary.withValues(alpha: 0.5),
                        fontSize: 11,
                      ),
                    ),
                  ),
                  const SizedBox(height: 4),
                ],
                // Description
                if (med.description != null && med.description!.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 8),
                    child: Text(
                      med.description!,
                      style: TextStyle(
                        color: onPrimary.withValues(alpha: 0.8),
                        fontStyle: FontStyle.italic,
                        fontSize: 10,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.scale,
                              size: 12,
                              color: onPrimary.withValues(alpha: 0.75),
                            ),
                            const SizedBox(width: 6),
                            Text(
                              strengthPerLabel,
                              style: TextStyle(
                                color: onPrimary.withValues(alpha: 0.7),
                                fontSize: 10,
                              ),
                            ),
                          ],
                        ),
                        Text(
                          '${_formatNumber(med.strengthValue)} ${_unitLabel(med.strengthUnit)}',
                          style: TextStyle(
                            color: onPrimary,
                            fontWeight: FontWeight.bold,
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                    icon: med.activeVialRequiresFreezer
                        ? Icons.ac_unit
                        : (med.requiresRefrigeration
                              ? Icons.ac_unit
                              : Icons.location_on),
                    label: med.activeVialRequiresFreezer
                      ? 'Storage Location (Frozen)'
                      : (med.requiresRefrigeration
                          ? 'Storage Location (Cold)'
                          : 'Storage Location'),
                    value: storageLabel,
                    textColor: onPrimary,
                    trailingIcon: med.activeVialLightSensitive
                        ? Icons.dark_mode_outlined
                        : null,
                  ),
                  const SizedBox(height: 8),
                ],
                // Reduce large spacer above adherence graph so it visually connects
                const SizedBox(height: kSpacingS),
                const Spacer(),
                _buildAdherenceGraph(context, onPrimary, med),
              ],
            ),
          ),
          const SizedBox(width: 16),
          Column(
            mainAxisAlignment: MainAxisAlignment.end,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              SizedBox(
                height: 100,
                width: 100,
                child: isMdv
                    ? DualStockDonutGauge(
                        outerPercentage: pct,
                        innerPercentage: backupPct,
                        primaryLabel: donutLabel,
                        labelStyle: Theme.of(context).textTheme.titleMedium
                            ?.copyWith(
                              fontWeight: FontWeight.w700,
                              color: onPrimary,
                            ),
                        color: gaugeColor,
                        backgroundColor: onPrimary.withValues(alpha: 0.05),
                        textColor: onPrimary,
                        showGlow: false,
                        isOutline: false,
                      )
                    : StockDonutGauge(
                        percentage: pct,
                        primaryLabel: donutLabel,
                        labelStyle: Theme.of(context).textTheme.titleMedium
                            ?.copyWith(
                              fontWeight: FontWeight.w700,
                              color: onPrimary,
                            ),
                        color: gaugeColor,
                        backgroundColor: onPrimary.withValues(alpha: 0.05),
                        textColor: onPrimary,
                        showGlow: false,
                        isOutline: false,
                      ),
              ),
              const SizedBox(height: 4),
              RichText(
                textAlign: TextAlign.right,
                text: TextSpan(
                  style: TextStyle(color: onPrimary, fontSize: 10),
                  children: [
                    TextSpan(
                      text: _formatNumber(
                        (isMdv &&
                                med.containerVolumeMl != null &&
                                med.containerVolumeMl! > 0)
                            ? (med.activeVialVolume ?? med.containerVolumeMl!)
                            : med.stockValue,
                      ),
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: theme.colorScheme.primaryContainer,
                      ),
                    ),
                    const TextSpan(text: ' / '),
                    TextSpan(
                      text: _formatNumber(initial),
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                    TextSpan(text: ' $unit'),
                  ],
                ),
              ),
              Text(
                helperLabel,
                style: TextStyle(
                  color: onPrimary.withValues(alpha: 0.7),
                  fontSize: 9,
                ),
                textAlign: TextAlign.right,
              ),
              const SizedBox(height: 8),
              // Stock Forecast (Moved Here)
              _buildStockForecastCard(context, onPrimary, med),
              const SizedBox(height: 8),
              // Custom Refill Button
              Container(
                height: 28,
                decoration: BoxDecoration(
                  color: onPrimary.withValues(alpha: 0.15),
                  borderRadius: BorderRadius.circular(14),
                  border: Border.all(
                    color: onPrimary.withValues(alpha: 0.3),
                    width: 1,
                  ),
                ),
                child: Material(
                  color: Colors.transparent,
                  child: InkWell(
                    onTap: () => _showRefillDialog(context, med),
                    borderRadius: BorderRadius.circular(14),
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 12),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.add_circle_outline,
                            size: 14,
                            color: onPrimary,
                          ),
                          const SizedBox(width: 6),
                          Text(
                            'Refill',
                            style: TextStyle(
                              color: onPrimary,
                              fontSize: 11,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Medication _applyRefillUpdate(
    Medication med,
    double qty,
    double topupMl,
    String batch,
  ) {
    final isMdv = med.form == MedicationForm.multiDoseVial;
    var updated = med;
    if (isMdv) {
      final newBackupCount = med.stockValue + qty;
      double newActive = med.activeVialVolume ?? med.containerVolumeMl ?? 0.0;
      final capacity = med.containerVolumeMl ?? 0.0;
      if (topupMl > 0 && capacity > 0) {
        newActive = (newActive + topupMl);
        if (newActive > capacity) {
          final overflow = newActive - capacity;
          final extraVials = (overflow / capacity).floor();
          newActive = newActive - extraVials * capacity;
        }
      }
      updated = updated.copyWith(
        stockValue: newBackupCount,
        activeVialVolume: newActive.clamp(0.0, double.infinity),
        backupVialsBatchNumber: batch.isNotEmpty
            ? batch
            : med.backupVialsBatchNumber,
      );
    } else {
      updated = updated.copyWith(
        stockValue: (med.stockValue + qty).clamp(0.0, double.infinity),
        batchNumber: batch.isNotEmpty ? batch : med.batchNumber,
      );
    }
    return updated;
  }

  void _showRefillDialog(BuildContext context, Medication med) {
    showModalBottomSheet<void>(
      context: context,
      isScrollControlled: true,
      builder: (c) {
        final qtyController = TextEditingController(text: '1');
        final topupController = TextEditingController(text: '0');
        final batchController = TextEditingController();
        final isMdv = med.form == MedicationForm.multiDoseVial;
        return StatefulBuilder(
          builder: (context, setState) {
            return Padding(
              padding: EdgeInsets.only(
                bottom: MediaQuery.of(context).viewInsets.bottom,
                left: 16,
                right: 16,
                top: 12,
              ),
              child: Wrap(
                children: [
                  ListTile(
                    title: Text('Refill ${med.name}'),
                    subtitle: Text(
                      isMdv
                          ? 'Multi-dose vial refill (backup or top-up)'
                          : 'Add to stock',
                    ),
                  ),
                  const SizedBox(height: 8),
                  TextField(
                    controller: qtyController,
                    keyboardType: const TextInputType.numberWithOptions(
                      decimal: true,
                    ),
                    decoration: buildFieldDecoration(
                      context,
                      hint: isMdv ? 'Backup vials to add' : 'Amount to add',
                    ),
                  ),
                  if (isMdv) ...[
                    const SizedBox(height: 8),
                    TextField(
                      controller: topupController,
                      keyboardType: const TextInputType.numberWithOptions(
                        decimal: true,
                      ),
                      decoration: buildFieldDecoration(
                        context,
                        hint: 'mL to top-up active vial',
                      ),
                    ),
                  ],
                  const SizedBox(height: 8),
                  TextField(
                    controller: batchController,
                    decoration: buildFieldDecoration(
                      context,
                      hint: 'Batch number (optional)',
                    ),
                  ),
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      Expanded(
                        child: FilledButton(
                          onPressed: () async {
                            final qty =
                                (double.tryParse(qtyController.text) ?? 0.0)
                                    .clamp(0.0, double.infinity);
                            final topup =
                                (double.tryParse(topupController.text) ?? 0.0)
                                    .clamp(0.0, double.infinity);
                            final batch = batchController.text.trim();
                            if (qty <= 0 && topup <= 0) {
                              if (context.mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                    content: Text('Enter amount to add'),
                                  ),
                                );
                              }
                              return;
                            }
                            final updated = _applyRefillUpdate(
                              med,
                              qty,
                              topup,
                              batch,
                            );
                            final box = Hive.box<Medication>('medications');
                            await box.put(updated.id, updated);
                            if (context.mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(content: Text('Refill saved')),
                              );
                              Navigator.pop(context);
                            }
                          },
                          child: const Text('Refill'),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                ],
              ),
            );
          },
        );
      },
    );
  }

  Widget _buildReconstitutionCard(BuildContext context, Medication med) {
    if (med.form != MedicationForm.multiDoseVial ||
        med.strengthValue <= 0 ||
        (med.containerVolumeMl == null && med.perMlValue == null)) {
      return const SizedBox.shrink();
    }

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 0),
      child: Stack(
        children: [
          ReconstitutionSummaryCard(
            strengthValue: med.strengthValue,
            strengthUnit: _unitLabel(med.strengthUnit),
            medicationName: med.name,
            containerVolumeMl: med.containerVolumeMl,
            perMlValue: med.perMlValue,
            volumePerDose: med.volumePerDose,
            reconFluidName: med.diluentName ?? 'Bacteriostatic Water',
            syringeSizeMl: 3.0,
          ),
          Positioned(
            top: 8,
            right: 8,
            child: IconButton(
              icon: Icon(
                Icons.edit_outlined,
                size: 20,
                color: Theme.of(context).colorScheme.primary,
              ),
              onPressed: () async {
                final result = await showModalBottomSheet<ReconstitutionResult>(
                  context: context,
                  isScrollControlled: true,
                  backgroundColor: Colors.transparent,
                  builder: (context) => ReconstitutionCalculatorDialog(
                    initialStrengthValue: med.strengthValue,
                    unitLabel: _unitLabel(med.strengthUnit),
                    initialDoseValue: med.volumePerDose,
                    initialVialSize: med.containerVolumeMl,
                  ),
                );

                if (result != null && context.mounted) {
                  final now = DateTime.now();
                  final updatedMed = med.copyWith(
                    containerVolumeMl: result.solventVolumeMl,
                    perMlValue: result.perMlConcentration,
                    volumePerDose: result.recommendedUnits / 100,
                    reconstitutedAt: now,
                    reconstitutedVialExpiry: now.add(const Duration(hours: 48)),
                  );
                  final box = await Hive.openBox<Medication>('medications');
                  await box.put(updatedMed.id, updatedMed);
                }
              },
              tooltip: 'Edit Reconstitution',
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCompactGrid(BuildContext context, List<Widget> children) {
    final rows = <Widget>[];
    for (var i = 0; i < children.length; i += 2) {
      rows.add(
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(child: children[i]),
            const SizedBox(width: 12),
            if (i + 1 < children.length)
              Expanded(child: children[i + 1])
            else
              const Spacer(),
          ],
        ),
      );
      if (i + 2 < children.length) {
        rows.add(const SizedBox(height: 12));
      }
    }
    return Column(children: rows);
  }

  Widget _buildCompactInfoItem(
    BuildContext context, {
    required String label,
    required String value,
    VoidCallback? onTap,
    bool highlighted = false,
    bool warning = false,
  }) {
    final theme = Theme.of(context);

    Widget content = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurface,
            fontSize: 11,
          ),
        ),
        const SizedBox(height: 2),
        Text(
          value,
          style: theme.textTheme.bodyMedium?.copyWith(
            fontWeight: highlighted ? FontWeight.bold : FontWeight.w500,
            color: warning
                ? theme.colorScheme.error
                : theme.colorScheme.onSurface,
            fontSize: 13,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
      ],
    );

    if (onTap != null) {
      return InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(8),
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 4),
          child: Row(
            children: [
              Expanded(child: content),
              Icon(
                Icons.edit_outlined,
                size: 14,
                color: theme.colorScheme.primary.withValues(alpha: 0.5),
              ),
            ],
          ),
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 4),
      child: content,
    );
  }
}

// We'll reinsert the widget & helper classes at the end of the file to ensure
// the state class includes all its helper methods.

// Helper methods

bool _isExpiringSoon(DateTime expiry) {
  final now = DateTime.now();
  return expiry.isBefore(now.add(const Duration(days: 30)));
}

String _formLabel(MedicationForm form) => switch (form) {
  MedicationForm.tablet => 'Tablet',
  MedicationForm.capsule => 'Capsule',
  MedicationForm.prefilledSyringe => 'Pre-filled Syringe',
  MedicationForm.singleDoseVial => 'Single Dose Vial',
  MedicationForm.multiDoseVial => 'Multi Dose Vial',
};

String _unitLabel(Unit unit) => switch (unit) {
  Unit.mcg => 'mcg',
  Unit.mg => 'mg',
  Unit.g => 'g',
  Unit.units => 'units',
  Unit.mcgPerMl => 'mcg/mL',
  Unit.mgPerMl => 'mg/mL',
  Unit.gPerMl => 'g/mL',
  Unit.unitsPerMl => 'units/mL',
};

String _stockUnitLabel(StockUnit unit) => switch (unit) {
  StockUnit.tablets => 'tablets',
  StockUnit.capsules => 'capsules',
  StockUnit.preFilledSyringes => 'syringes',
  StockUnit.singleDoseVials => 'vials',
  StockUnit.multiDoseVials => 'vials',
  StockUnit.mcg => 'mcg',
  StockUnit.mg => 'mg',
  StockUnit.g => 'g',
};

String _formatNumber(double value) {
  if (value == value.roundToDouble()) {
    return value.toInt().toString();
  }
  return value.toStringAsFixed(1);
}

// `_stockFillRatio` has been replaced by `MedicationDisplayHelpers.calculateStock`.

ScheduledDose? _nextDoseForMedication(String medId) {
  final schedulesBox = Hive.box<Schedule>('schedules');
  final schedules = schedulesBox.values
      .where((s) => s.medicationId == medId && s.active)
      .toList();

  if (schedules.isEmpty) return null;

  final now = DateTime.now();
  DateTime? nextTime;
  Schedule? nextSchedule;

  for (final schedule in schedules) {
    final times = schedule.hasMultipleTimes
        ? schedule.timesOfDay!
        : [schedule.minutesOfDay];

    for (final minutes in times) {
      final hour = minutes ~/ 60;
      final minute = minutes % 60;
      var candidate = DateTime(now.year, now.month, now.day, hour, minute);

      if (candidate.isBefore(now)) {
        candidate = candidate.add(const Duration(days: 1));
      }

      if (nextTime == null || candidate.isBefore(nextTime)) {
        nextTime = candidate;
        nextSchedule = schedule;
      }
    }
  }

  return nextTime != null
      ? ScheduledDose(nextTime, schedule: nextSchedule)
      : null;
}

// Note: Refill helpers live as instance methods in `_MedicationDetailPageState`.

Future<void> _showEditDialog(
  BuildContext context,
  Medication med,
  String title,
  String initialValue,
  void Function(String) onSave, {
  int maxLines = 1,
  TextInputType? keyboardType,
}) async {
  final controller = TextEditingController(text: initialValue);
  final result = await showDialog<String>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(title),
      content: TextField(
        controller: controller,
        decoration: buildFieldDecoration(context, hint: 'Enter $title'),
        maxLines: maxLines,
        keyboardType: keyboardType,
        autofocus: true,
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: () => Navigator.pop(context, controller.text),
          child: const Text('Save'),
        ),
      ],
    ),
  );

  if (result != null && result != initialValue) {
    onSave(result);
  }
}

Future<void> _editDate(
  BuildContext context,
  Medication med,
  String title,
  DateTime? initialDate,
  void Function(DateTime) onSave,
) async {
  final picked = await showDatePicker(
    context: context,
    initialDate: initialDate ?? DateTime.now(),
    firstDate: DateTime.now().subtract(const Duration(days: 365 * 2)),
    lastDate: DateTime.now().add(const Duration(days: 365 * 5)),
  );
  if (picked != null) {
    onSave(picked);
  }
}

void _editName(BuildContext context, Medication med) {
  _showEditDialog(context, med, 'Medication Name', med.name, (val) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(name: val));
  });
}

void _editManufacturer(BuildContext context, Medication med) {
  _showEditDialog(context, med, 'Manufacturer', med.manufacturer ?? '', (val) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(manufacturer: val));
  });
}

void _editBatchNumber(BuildContext context, Medication med) {
  _showEditDialog(context, med, 'Batch Number', med.batchNumber ?? '', (val) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(batchNumber: val));
  });
}

void _editExpiry(BuildContext context, Medication med) {
  _editDate(context, med, 'Expiry Date', med.expiry, (val) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(expiry: val));
  });
}

void _editStorageLocation(BuildContext context, Medication med) {
  _showEditDialog(context, med, 'Storage Location', med.storageLocation ?? '', (
    val,
  ) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(storageLocation: val));
  });
}

void _editStorageInstructions(BuildContext context, Medication med) {
  _showEditDialog(
    context,
    med,
    'Storage Instructions',
    med.storageInstructions ?? '',
    (val) {
      final box = Hive.box<Medication>('medications');
      box.put(med.id, med.copyWith(storageInstructions: val));
    },
    maxLines: 3,
  );
}

void _editStrength(BuildContext context, Medication med) async {
  final valueController = TextEditingController(
    text: med.strengthValue.toString(),
  );
  Unit selectedUnit = med.strengthUnit;
  final result = await showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      title: const Text('Edit Strength'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: valueController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: buildFieldDecoration(context, hint: 'Strength value'),
          ),
          const SizedBox(height: 8),
          DropdownButtonFormField<Unit>(
            value: selectedUnit,
            items: Unit.values
                .map(
                  (u) => DropdownMenuItem(value: u, child: Text(_unitLabel(u))),
                )
                .toList(),
            onChanged: (u) => selectedUnit = u ?? selectedUnit,
            decoration: buildFieldDecoration(context, hint: 'Unit'),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context, false),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: () => Navigator.pop(context, true),
          child: const Text('Save'),
        ),
      ],
    ),
  );
  if (result == true) {
    final d = double.tryParse(valueController.text);
    if (d != null) {
      final box = Hive.box<Medication>('medications');
      box.put(
        med.id,
        med.copyWith(strengthValue: d, strengthUnit: selectedUnit),
      );
    }
  }
}

void _editNotes(BuildContext context, Medication med) {
  _showEditDialog(context, med, 'Notes', med.notes ?? '', (val) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(notes: val));
  }, maxLines: 3);
}

void _editDescription(BuildContext context, Medication med) {
  _showEditDialog(context, med, 'Description', med.description ?? '', (val) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(description: val));
  }, maxLines: 3);
}

void _editLowStockThreshold(BuildContext context, Medication med) {
  _showEditDialog(
    context,
    med,
    'Low Stock Threshold',
    med.lowStockThreshold?.toString() ?? '',
    (val) {
      final d = double.tryParse(val);
      if (d != null) {
        final box = Hive.box<Medication>('medications');
        box.put(
          med.id,
          med.copyWith(lowStockThreshold: d, lowStockEnabled: true),
        );
      }
    },
    keyboardType: const TextInputType.numberWithOptions(decimal: true),
  );
}

// MDV Specific Edits
void _editActiveVialBatch(BuildContext context, Medication med) {
  _showEditDialog(
    context,
    med,
    'Active Vial Batch',
    med.activeVialBatchNumber ?? '',
    (val) {
      final box = Hive.box<Medication>('medications');
      box.put(med.id, med.copyWith(activeVialBatchNumber: val));
    },
  );
}

void _editActiveVialLocation(BuildContext context, Medication med) {
  _showEditDialog(
    context,
    med,
    'Active Vial Location',
    med.activeVialStorageLocation ?? '',
    (val) {
      final box = Hive.box<Medication>('medications');
      box.put(med.id, med.copyWith(activeVialStorageLocation: val));
    },
  );
}

void _editActiveVialLowStock(BuildContext context, Medication med) {
  _showEditDialog(
    context,
    med,
    'Active Vial Low Stock (mL)',
    med.activeVialLowStockMl?.toString() ?? '',
    (val) {
      final d = double.tryParse(val);
      if (d != null) {
        final box = Hive.box<Medication>('medications');
        box.put(med.id, med.copyWith(activeVialLowStockMl: d));
      }
    },
    keyboardType: const TextInputType.numberWithOptions(decimal: true),
  );
}

void _editBackupVialBatch(BuildContext context, Medication med) {
  _showEditDialog(
    context,
    med,
    'Backup Vial Batch',
    med.backupVialsBatchNumber ?? '',
    (val) {
      final box = Hive.box<Medication>('medications');
      box.put(med.id, med.copyWith(backupVialsBatchNumber: val));
    },
  );
}

void _editBackupVialLocation(BuildContext context, Medication med) {
  _showEditDialog(
    context,
    med,
    'Backup Vial Location',
    med.backupVialsStorageLocation ?? '',
    (val) {
      final box = Hive.box<Medication>('medications');
      box.put(med.id, med.copyWith(backupVialsStorageLocation: val));
    },
  );
}

void _editBackupVialExpiry(BuildContext context, Medication med) {
  _editDate(context, med, 'Backup Vial Expiry', med.backupVialsExpiry, (val) {
    final box = Hive.box<Medication>('medications');
    box.put(med.id, med.copyWith(backupVialsExpiry: val));
  });
}

void _deleteMedication(BuildContext context, Medication med) async {
  final confirm = await showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      title: const Text('Delete Medication'),
      content: Text(
        'Are you sure you want to delete ${med.name}? This action cannot be undone.',
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context, false),
          child: const Text('Cancel'),
        ),
        FilledButton(
          style: FilledButton.styleFrom(
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
          onPressed: () => Navigator.pop(context, true),
          child: const Text('Delete'),
        ),
      ],
    ),
  );

  if (confirm == true) {
    final box = Hive.box<Medication>('medications');
    await box.delete(med.id);
    if (context.mounted) {
      context.pop(); // Go back to list
    }
  }
}

void _showMedicationInfoEditorSheet(
  BuildContext context,
  Medication med,
) async {
  await showModalBottomSheet<void>(
    context: context,
    builder: (context) => SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ListTile(
            leading: const Icon(Icons.drive_file_rename_outline),
            title: const Text('Edit Name'),
            onTap: () {
              Navigator.pop(context);
              _editName(context, med);
            },
          ),
          ListTile(
            leading: const Icon(Icons.domain),
            title: const Text('Edit Manufacturer'),
            onTap: () {
              Navigator.pop(context);
              _editManufacturer(context, med);
            },
          ),
          ListTile(
            leading: const Icon(Icons.scale),
            title: const Text('Edit Strength'),
            onTap: () {
              Navigator.pop(context);
              _editStrength(context, med);
            },
          ),
          ListTile(
            leading: const Icon(Icons.storage),
            title: const Text('Edit Storage Location'),
            onTap: () {
              Navigator.pop(context);
              _editStorageLocation(context, med);
            },
          ),
          ListTile(
            leading: const Icon(Icons.notes),
            title: const Text('Edit Notes'),
            onTap: () {
              Navigator.pop(context);
              _editNotes(context, med);
            },
          ),
          ListTile(
            leading: const Icon(Icons.description_outlined),
            title: const Text('Edit Description'),
            onTap: () {
              Navigator.pop(context);
              _editDescription(context, med);
            },
          ),
        ],
      ),
    ),
  );
}

Widget _buildAdherenceGraph(BuildContext context, Color color, Medication med) {
  final doseBox = Hive.box<DoseLog>('dose_logs');
  final scheduleBox = Hive.box<Schedule>('schedules');

  final now = DateTime.now();
  final today = DateTime(now.year, now.month, now.day);
  final data = <double>[];

  final schedules = scheduleBox.values
      .where((s) => s.medicationId == med.id && s.active)
      .toList();

  if (schedules.isEmpty) {
    return const SizedBox.shrink();
  }

  for (int i = 6; i >= 0; i--) {
    final date = today.subtract(Duration(days: i));
    final dayOfWeek = date.weekday;
    final isScheduledDay = schedules.any(
      (s) => s.daysOfWeek.contains(dayOfWeek),
    );

    if (!isScheduledDay) {
      data.add(-1.0);
      continue;
    }

    final taken = doseBox.values.any((log) {
      final localScheduled = log.scheduledTime.toLocal();
      return log.medicationId == med.id &&
          log.action == DoseAction.taken &&
          localScheduled.year == date.year &&
          localScheduled.month == date.month &&
          localScheduled.day == date.day;
    });

    data.add(taken ? 1.0 : 0.0);
  }

  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Text(
        '7 Day Adherence',
        style: TextStyle(color: color.withValues(alpha: 0.7), fontSize: 10),
      ),
      const SizedBox(height: 8),
      SizedBox(
        height: 40,
        width: double.infinity,
        child: CustomPaint(
          painter: _AdherenceBarPainter(data: data, color: color),
        ),
      ),
    ],
  );
}

Widget _buildStockForecastCard(
  BuildContext context,
  Color color,
  Medication med,
) {
  final scheduleBox = Hive.box<Schedule>('schedules');
  final schedules = scheduleBox.values
      .where((s) => s.medicationId == med.id && s.active)
      .toList();

  if (schedules.isEmpty || med.stockValue <= 0) {
    return const SizedBox.shrink();
  }

  double weeklyConsumption = 0;
  for (final schedule in schedules) {
    final dosesPerDay = schedule.hasMultipleTimes
        ? schedule.timesOfDay!.length
        : 1;
    final daysPerWeek = schedule.daysOfWeek.length;

    double amountPerDose = 1.0;
    if (med.form == MedicationForm.tablet ||
        med.form == MedicationForm.capsule) {
      if (schedule.doseValue > 0) {
        amountPerDose = schedule.doseValue;
      }
    }

    weeklyConsumption += dosesPerDay * daysPerWeek * amountPerDose;
  }

  if (weeklyConsumption == 0) return const SizedBox.shrink();

  final dailyConsumption = weeklyConsumption / 7.0;

  double totalStockDoses = med.stockValue;

  if (med.form == MedicationForm.multiDoseVial) {
    if (med.containerVolumeMl != null &&
        med.volumePerDose != null &&
        med.volumePerDose! > 0) {
      final activeVol = med.activeVialVolume ?? med.containerVolumeMl!;
      final sealedVol = med.stockValue * med.containerVolumeMl!;
      final totalVol = activeVol + sealedVol;
      totalStockDoses = totalVol / med.volumePerDose!;
    }
  }

  final daysRemaining = totalStockDoses / dailyConsumption;
  final date = DateTime.now().add(Duration(days: daysRemaining.floor()));
  final dateStr = DateFormat('MMM d, y').format(date);

  final expiry = med.expiry;
  bool expiresBeforeStockout = false;
  if (expiry != null && expiry.isBefore(date)) {
    expiresBeforeStockout = true;
  }

  return Column(
    crossAxisAlignment: CrossAxisAlignment.end,
    children: [
      Text(
        'Stock Forecast',
        style: TextStyle(color: color.withValues(alpha: 0.7), fontSize: 10),
        textAlign: TextAlign.right,
      ),
      const SizedBox(height: 2),
      Text(
        'Based on current schedule',
        style: TextStyle(
          color: color.withValues(alpha: 0.5),
          fontSize: 9,
          fontStyle: FontStyle.italic,
        ),
        textAlign: TextAlign.right,
      ),
      Text(
        'Expected to last until',
        style: TextStyle(
          color: color.withValues(alpha: 0.5),
          fontSize: 10,
          fontStyle: FontStyle.italic,
        ),
        textAlign: TextAlign.right,
      ),
      Text(
        dateStr,
        style: TextStyle(
          color: color,
          fontWeight: FontWeight.bold,
          fontSize: 14,
        ),
        textAlign: TextAlign.right,
      ),
      Text(
        '${daysRemaining.floor()} days',
        style: TextStyle(
          color: color.withValues(alpha: 0.9),
          fontSize: 12,
          fontWeight: FontWeight.w500,
        ),
        textAlign: TextAlign.right,
      ),
      if (expiry != null) ...[
        const SizedBox(height: 4),
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            Icon(
              Icons.event,
              size: 12,
              color: expiresBeforeStockout
                  ? Theme.of(context).colorScheme.errorContainer
                  : color.withValues(alpha: 0.7),
            ),
            const SizedBox(width: 4),
            Text(
              'Expires: ${DateFormat('MMM d, y').format(expiry)}',
              style: TextStyle(
                color: expiresBeforeStockout
                    ? Theme.of(context).colorScheme.errorContainer
                    : color.withValues(alpha: 0.7),
                fontSize: 10,
                fontWeight: expiresBeforeStockout
                    ? FontWeight.bold
                    : FontWeight.normal,
              ),
            ),
          ],
        ),
      ],
    ],
  );
}
